quit
n
@moves
display valid
quit
@moves
s
display valid
exit
quit
board[next_pos]
board[next_pos].is_a?(NullPiece)
next_pos
s
self.pos.first + 1
self.pos.first
dx
s
dx
s
dy
dx
s
directions
s
board[next_pos].is_a?(NullPiece)
board[next_pos]
next_pos
s
self.pos.last
self.pos.first
s
dx.abs
s
dx
quit
piece.pos
piece.moves
piece.color != color
piece
s
row.first.moves
row[7].class
row[6].class
row[5].class
row[4].class
row[3].class
row[2].class
row[1].class
row.any? { |piece| piece.color != color && piece.moves.include?(pos) }
row.first.color
row.first.class
n
display row.any? { |piece| piece.color != color && piece.moves.include?(pos) }
n
s
row.any? { |piece| piece.color != color && piece.moves.include?(pos) }
s
row.any? { |piece| piece.color != color && piece.moves.include?(pos) }
s
row.any? { |piece| piece.color != color && piece.moves.include?(pos) }
s
row.any? { |piece| piece.color != color && piece.moves.include?(pos) }
s
row.any? { |piece| piece.color != color && piece.moves.include?(pos) }
s
row.any? { |piece| piece.color != color && piece.moves.include?(pos) }
s
row.any? { |piece| piece.color != color && piece.moves.include?(pos) }
s
row
s
n
s
find_king(:black)
color
s
@board.in_check?(:black)
@board.in_check?(self.color)
self.color
@board[end_pos]
dis.render
end_pos
quit
s
up
n
moves.select { |pos| @board.in_bounds?(pos) }
moves
n
directions
n
directions
n
display moves
s
quit
n
s
n
el.color == color
el.is_a?(King)
el
[i, j]
s
[i, j]
s
[i, j]
el
s
[i, j]
row
color
quit
el.color == color
el.is_a?(King)
[i, j]
el
s
n
row
quit
j
i
pos
quit
q
n
self[end_pos]
n
@grid[row][col]
col
row
s
value
pos
n
@grid[row][col]
col
row
s
pos
quit
n
s
self[start_pos]
s
value
@grid[row][col]
col
row
s
value
pos
s
@grid[row][col]
@grid[0][0]
col
row
s
pos
quit
display i
board[i][j]
j
s
i
row
s
board[6..7]
board
